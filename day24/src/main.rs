use std::{
    collections::HashMap,
    io::{stdin, BufRead},
};

use anyhow::{bail, Result};
use clap::{Parser, Subcommand};

#[derive(Debug, Subcommand)]
enum Part {
    P1,
    P2,
}

#[derive(Parser, Debug)]
struct Args {
    #[command(subcommand)]
    part: Part,
}

#[derive(Debug, Clone, Copy)]
enum Operator {
    AND,
    OR,
    XOR,
}

impl Operator {
    fn eval(&self, op1: bool, op2: bool) -> bool {
        match self {
            Operator::AND => op1 && op2,
            Operator::OR => op1 || op2,
            Operator::XOR => op1 ^ op2,
        }
    }
}

#[derive(Debug, Clone)]
struct Gate {
    op1: String,
    op2: String,
    op: Operator,
}

struct Input {
    inits: HashMap<String, bool>,
    gates: HashMap<String, Gate>,
}

fn input(inp: impl BufRead) -> Result<Input> {
    let mut inits = HashMap::new();
    let mut lines = inp.lines();
    for line in &mut lines {
        let line = line?;
        if line.is_empty() {
            break;
        }

        let Some((s, b)) = line.split_once(": ") else {
            bail!("Failed to parse line");
        };
        inits.insert(
            s.to_string(),
            match b {
                "1" => true,
                "0" => false,
                _ => bail!("Failed to parse init val"),
            },
        );
    }

    let mut gates = HashMap::new();
    for line in lines {
        let line = line?;
        let mut toks = line.split_whitespace();
        let (Some(op1), Some(op), Some(op2), Some(_), Some(out)) = (
            toks.next().map(str::to_string),
            toks.next(),
            toks.next().map(str::to_string),
            toks.next(),
            toks.next().map(str::to_string),
        ) else {
            bail!("Failed to parse gate");
        };
        let op = match op {
            "AND" => Operator::AND,
            "OR" => Operator::OR,
            "XOR" => Operator::XOR,
            _ => bail!("Failed to parse operator"),
        };

        gates.insert(out, Gate { op1, op2, op });
    }

    Ok(Input { inits, gates })
}

fn node(ch: char, i: usize) -> String {
    format!("{ch}{i:0>2}")
}

const EVAL_MAX_DEPTH: usize = 10;
fn try_eval(
    memo: &mut HashMap<String, bool>,
    gates: &HashMap<String, Gate>,
    s: &String,
    depth: usize,
) -> Option<bool> {
    if depth > EVAL_MAX_DEPTH {
        println!("Recursion depth exceeded");
        None
    } else if let Some(&val) = memo.get(s) {
        Some(val)
    } else if let Some(gate) = gates.get(s) {
        let op1 = try_eval(memo, gates, &gate.op1, depth + 1)?;
        let op2 = try_eval(memo, gates, &gate.op2, depth + 1)?;
        let out = gate.op.eval(op1, op2);
        memo.insert(s.clone(), out);
        Some(out)
    } else {
        None
    }
}

fn main() -> Result<()> {
    let args = Args::parse();
    let inp = input(stdin().lock())?;

    match args.part {
        Part::P1 => {
            let mut z = 0;
            let mut memo = inp.inits;
            for i in 0.. {
                let Some(val) = try_eval(&mut memo, &inp.gates, &node('z', i), 0) else {
                    break;
                };
                z |= (val as usize) << i;
            }
            println!("{z}");
        }
        Part::P2 => {
            println!("Suspicious gates:");
            for (n, gate) in &inp.gates {
                if !n.starts_with('z') {
                    continue;
                }
                if !matches!(gate.op, Operator::XOR) {
                    println!("{n} is not XOR")
                }
            }

            // Generated by manually inspecting suspicious gates
            let mut v = vec!["z11", "wpd", "skh", "jqf", "z19", "mdd", "wts", "z37"];
            v.sort();
            println!("{}", v.join(","));
        }
    }

    Ok(())
}
